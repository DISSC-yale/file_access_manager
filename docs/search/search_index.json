{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Python command-line interface package to manage access to directories.</p> <p>The main use-case in mind is to manage access of researchers to data files.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Grant or revoke access of users or groups of users (e.g., principal investigators and their collaborators or research assistants)</li> <li>Keep a list of users needing access, pending account creation</li> <li>Establish named paths (e.g., dataset names associated with their location)</li> <li>Track access status changes of users and datasets</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<p>This package manages access through Access Control Lists, so this should work on any system with the <code>getfacl</code> and <code>setfacl</code> commands.</p>"},{"location":"#installation","title":"Installation","text":"<p>If needed, download Python from python.org, then install the package with pip:</p> <pre><code>pip install git+https://github.com/DISSC-yale/file_access_manager.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Initialize an access management project:</p> <pre><code>manage-access init\n</code></pre> <p>Name a location:</p> <pre><code>manage-access locations location_name /full/path/to/location\n</code></pre> <p>Check current access to that location:</p> <pre><code>manage-access check -l location_name\n</code></pre> <p>Manage access to that location:</p> <pre><code># add a user\nmanage-access location_name user1\n\n# add a user to that user's group\nmanage-access location_name user2 user1\n\n# remove user and their group(s) from all locations\nmanage-access -r user1\n</code></pre>"},{"location":"Automation/","title":"Automation","text":"<p>It may be useful to regularly run some commands:</p> <ul> <li><code>manage-access check</code> to keep access up-to-date within each location as their contents might change.</li> <li><code>manage-access pending</code> to apply access to users that didn't exist within the initial system.</li> </ul> <p>If access is being managed across systems, it may also be useful to automatically pull in the access management project, and push it as access is updated.</p> <p>These tasks could be brought together in a script:</p> <pre><code>#!/bin/bash\n\ncd /path/to/access_record\ngit pull\n\nmanage-access pending --push\nmanage-access check\n</code></pre> <p>This script could also be used to keep this tool up to date:</p> <pre><code>pip uninstall -y file_access_manager\npip install https://github.com/DISSC-yale/file_access_manager/archive/main.tar.gz\n</code></pre> <p>This script could then be run automatically with a cron job (e.g., to be run every 30 minutes):</p> <pre><code>*/30 * * * * source script_name.sh\n</code></pre>"},{"location":"Automation/#slurm","title":"Slurm","text":"<p>If access is being managed on a cluster using Slurm, you might add an initial module load to the script:</p> <pre><code># depending on what an appropriate module would be in your system\nmodule load python/3.10\n</code></pre> <p>And a scron job could run the script using the same syntax.</p>"},{"location":"Automation/#mixed-ownership","title":"Mixed Ownership","text":"<p>Access Control Lists can only be applied or changed on files you own, so in cases where a directory contains files owned by different people, every owner would need to run <code>manage-access check</code>. This will attempt to apply access to everything, but will continue through failure to catch any owned files.</p> <p>In this case, it might be useful to have a secondary script that only applies access (i.e., does not change any of the access_record files):</p> <pre><code>#!/bin/bash\n\ncd /path/to/access_record\n\nmanage-access pending --no-pull --no-update\nmanage-access check --no-pull\n</code></pre>"},{"location":"Automation/#complete-example","title":"Complete Example","text":"<p>This is an example of starting and managing an automated access management project.</p>"},{"location":"Automation/#initialize","title":"Initialize","text":"<p>Say a set of files lives on cluster storage at <code>/data/setname</code>.</p> <p>We might start an access management project at <code>/data/admin</code>, with a location pointing to the controlled directory:</p> <pre><code>cd /data\nmanage-access init admin\nmanage-access locations setname /data/setname\n</code></pre> <p>Then upload to a remote repository (e.g., dissc-yale/access_record):</p> <pre><code>git remote add origin git@github.com:dissc-yale/access_record.git\ngit branch -M main\ngit push --set-upstream origin main\n</code></pre>"},{"location":"Automation/#add-scripts","title":"Add Scripts","text":"<p><code>/data/admin/primary_script.sh</code>:</p> <pre><code>#!/bin/bash\n\nmodule load python/3.10\n\ncd /data/admin\ngit pull\n\npip uninstall -y file_access_manager\npip install https://github.com/DISSC-yale/file_access_manager/archive/main.tar.gz\n\nmanage-access pending --push\nmanage-access check\n</code></pre> <p><code>/data/admin/secondary_script.sh</code>:</p> <pre><code>#!/bin/bash\n\nmodule load python/3.10\n\ncd /data/admin\n\nmanage-access pending --no-pull --no-update\nmanage-access check --no-pull\n</code></pre> <p>Make sure to commit and push these after adding them.</p> <p>Then establish a cron job (e.g., with <code>crontab -e</code> or <code>scrontab -e</code>):</p> <pre><code># this also adds a log output to the management repository\n#SCRON -o /data/admin/logs/primary_job-%j.out\n*/30 * * * * source /data/admin/primary_script.sh\n</code></pre>"},{"location":"Automation/#management","title":"Management","text":"<p>Now new access changes can be made anywhere and pushed to the management repo, which will then be pulled in by <code>primary_script.sh</code>, applied, and updated:</p> <pre><code>sequenceDiagram\n    Participant Local\n    Remote -&gt;&gt; Local: pull in the access_record repository\n    Local -&gt;&gt; Local: make access changes with a `manage-access` command\n    Local -&gt;&gt; Remote: push changes\n    Remote -&gt;&gt; Cluster: changes pulled in (by primary_script.sh)\n    Cluster -&gt;&gt; Cluster: changes are applied (by `manage-access pending`)\n    Cluster -&gt;&gt; Remote: changes pushed (by primary_script.sh)\n    Remote -&gt;&gt; Local: pull in latest changes to see current state</code></pre>"},{"location":"Projects/","title":"Projects","text":"<p>Projects keep a record of access and changes to access. Initialize a project with the init command:</p> <pre><code>manage-access init ./access_record\ncd access_record\n</code></pre> <p>This will create the following initial files:</p> <pre><code>access_record/\n  .git\n  .gitignore\n  access.csv\n  config.json\n  locations.json\n  log.txt\n  pending_access.csv\n</code></pre> <p><code>access.csv</code> keeps a record of what should be current user access. It is a comma delimited file with these columns:</p> <ul> <li><code>user</code>: Name of the user receiving access.</li> <li><code>group</code>: Group under which the user is receiving access. This will default to the user themselves.</li> <li><code>location</code>: Path to the directory the user is receiving access to.</li> <li><code>permissions</code>: Type of access the user should have; <code>rx</code> by default.</li> <li><code>date</code>: Date and time at which permission was set.</li> </ul> <p>This is added to each time a user is granted access to a location, and is removed from when that access is revoked.</p> <p><code>pending_access.csv</code> is the same structure as <code>access.csv</code>. Users are added here if they cannot be found on the system.</p> <p><code>locations.json</code> keeps an association between names and full paths, for convenience. This is only used for initial translation, such that stored references to locations are always the associated path, rather than the name.</p> <p><code>log.txt</code> keeps a log of events.</p>"},{"location":"functions/Access/","title":"Access","text":"<p>Manage user access.</p>"},{"location":"functions/Access/#file_access_manager.access.check_access","title":"<code>check_access(user=None, location=None, group=None, pull=True, reapply=True, verbose=True)</code>","text":"<p>List and confirm access for a given user, location, and/or group, or all current and pending access.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User to check access for.</p> <code>None</code> <code>location</code> <code>str</code> <p>Location to check access for.</p> <code>None</code> <code>group</code> <code>str</code> <p>Group to check access for.</p> <code>None</code> <code>pull</code> <code>bool</code> <p>If <code>False</code>, will not pull the remote before checking access.</p> <code>True</code> <code>reapply</code> <code>bool</code> <p>If <code>False</code>, will attempt to set all permissions check checking.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If <code>False</code>, will not print subset access.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>A tuple containing [0] current and [1] pending access.</p> Source code in <code>file_access_manager\\access.py</code> <pre><code>def check_access(\n    user: \"Union[str, None]\" = None,\n    location: \"Union[str, None]\" = None,\n    group: \"Union[str, None]\" = None,\n    pull=True,\n    reapply=True,\n    verbose=True,\n) -&gt; \"tuple[pandas.DataFrame, pandas.DataFrame]\":\n    \"\"\"\n    List and confirm access for a given user, location, and/or group, or all current and pending access.\n\n    Args:\n        user (str): User to check access for.\n        location (str): Location to check access for.\n        group (str): Group to check access for.\n        pull (bool): If `False`, will not pull the remote before checking access.\n        reapply (bool): If `False`, will attempt to set all permissions check checking.\n        verbose (bool): If `False`, will not print subset access.\n\n    Returns:\n        A tuple containing [0] current and [1] pending access.\n    \"\"\"\n    if pull and GIT_PATH and isdir(\".git\"):\n        if subprocess.run([GIT_PATH, \"pull\"], check=False, capture_output=True).stderr != b\"\":\n            warnings.warn(\"failed to pull before checking pending\", stacklevel=2)\n    access = _get_accesses()\n    pending = _get_pendings()\n    if location:\n        location = _get_locations().get(location, location)\n    if user:\n        access = access[access[\"user\"] == user]\n        pending = pending[pending[\"user\"] == user]\n    if location:\n        access = access[access[\"location\"] == location]\n        pending = pending[pending[\"location\"] == location]\n    if group:\n        access = access[access[\"group\"] == group]\n        pending = pending[pending[\"group\"] == group]\n    if len(access):\n        access[\"actual_permissions\"] = \"None\"\n        access[\"access_to_parents\"] = False\n        for check_location in access[\"location\"].unique():\n            if isdir(check_location):\n                target_access = access[access[\"location\"] == check_location]\n                current_access = _get_current_access(check_location)\n                for current_user in target_access[\"user\"].unique():\n                    target_perms = target_access[target_access[\"user\"] == current_user]\n                    if len(target_perms):\n                        current_perms = current_access.get(current_user)\n                        if reapply:\n                            res = _set_permissions(current_user, check_location, target_perms.iloc[0][\"permissions\"])\n                            if res.stderr == b\"\":\n                                current_perms = target_perms.iloc[0][\"permissions\"]\n                        access.loc[\n                            (access[\"location\"] == check_location) &amp; (access[\"user\"] == current_user),\n                            \"actual_permissions\",\n                        ] = current_perms\n                        access.loc[\n                            (access[\"location\"] == check_location) &amp; (access[\"user\"] == current_user),\n                            \"access_to_parents\",\n                        ] = _apply_to_parent(current_user, check_location, target_perms.iloc[0][\"parents\"])\n    if verbose:\n        if len(access):\n            print(\"current access:\\n\")\n            print(access.to_string())\n        if len(pending):\n            print(\"\\npending access:\\n\")\n            print(pending.to_string())\n        if len(access) == 0 and len(pending) == 0:\n            print(\"no access not found\")\n    return (access, pending)\n</code></pre>"},{"location":"functions/Access/#file_access_manager.access.check_pending","title":"<code>check_pending(pull=True, push=False, update=True)</code>","text":"<p>Check any users pending access, and apply permissions if they exist.</p> <p>Parameters:</p> Name Type Description Default <code>pull</code> <code>bool</code> <p>If <code>False</code>, will not pull the remote before checking pending.</p> <code>True</code> <code>push</code> <code>bool</code> <p>If <code>True</code>, will push any changes made (bypassing auto_push option).</p> <code>False</code> <code>update</code> <code>bool</code> <p>If <code>False</code>, will not change pending or access files.</p> <code>True</code> Source code in <code>file_access_manager\\access.py</code> <pre><code>def check_pending(pull=True, push=False, update=True):\n    \"\"\"\n    Check any users pending access, and apply permissions if they exist.\n\n    Args:\n        pull (bool): If `False`, will not pull the remote before checking pending.\n        push (bool): If `True`, will push any changes made (bypassing auto_push option).\n        update (bool): If `False`, will not change pending or access files.\n    \"\"\"\n    if pull and GIT_PATH and isdir(\".git\"):\n        if subprocess.run([GIT_PATH, \"pull\"], check=False, capture_output=True).stderr != b\"\":\n            warnings.warn(\"failed to pull before checking pending\", stacklevel=2)\n    pending_file = \"pending_\" + ACCESS_FILE\n    if isfile(pending_file):\n        pending = _get_pendings()\n        updated = False\n        for user, access in pending.groupby(\"user\"):\n            if _user_exists(user):\n                for group, location, permissions, parents in zip(\n                    access[\"group\"], access[\"location\"], access[\"permissions\"], access[\"parents\"]\n                ):\n                    if pandas.isna(permissions):\n                        revoke_permissions(user, \"\" if pandas.isna(location) else location, True)\n                        updated = True\n                    elif isdir(location):\n                        _set_permissions(user, location, permissions)\n                        _apply_to_parent(user, location, parents)\n                        updated = True\n                        current_access = _get_accesses()\n                        added_access = _append_row(current_access, user, group, location, permissions, parents)\n                        if update and not added_access.equals(current_access):\n                            added_access.to_csv(ACCESS_FILE, index=False)\n                            _log(f\"set permissions to {location} for {user} in group {group}\")\n                    if updated:\n                        pending = pending[~((pending[\"user\"] == user) &amp; (pending[\"location\"] == location))]\n        if update and updated:\n            pending.to_csv(pending_file, index=False)\n            _git_update(\"processed pending permissions\", push)\n    else:\n        print(\"no pending users\")\n</code></pre>"},{"location":"functions/Access/#file_access_manager.access.revoke_permissions","title":"<code>revoke_permissions(user, location=None, from_pending=False)</code>","text":"<p>Remove access from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User to remove access from.</p> required <code>location</code> <code>str</code> <p>Location to remove <code>user</code>s access from; if not specified, access from all locations will be removed.</p> <code>None</code> <code>from_pending</code> <code>bool</code> <p>If <code>False</code>, will not also remove the user from pending access.</p> <code>False</code> Source code in <code>file_access_manager\\access.py</code> <pre><code>def revoke_permissions(user: str, location: \"Union[str, None]\" = None, from_pending=False):\n    \"\"\"\n    Remove access from a user.\n\n    Args:\n        user (str): User to remove access from.\n        location (str): Location to remove `user`s access from; if not\n            specified, access from all locations will be removed.\n        from_pending (bool): If `False`, will not also remove the user from pending access.\n    \"\"\"\n    access = _get_accesses()\n    removed = su = access[\"user\"] == user\n    if any(su):\n        path = \"\"\n        any_fail = False\n        if location:\n            locations = _get_locations()\n            path = locations.get(location, location)\n        if not from_pending and _get_config().get(\"defer\", False):\n            pending = _get_pendings()\n            updated = _append_row(pending, user, user, path, \"\", 0)\n            if not updated.equals(pending):\n                updated.to_csv(\"pending_\" + ACCESS_FILE, index=False)\n                message = f\"added {user} to pending removal\" + (f\" from {location}\" if location else \"\")\n                _log(message)\n                _git_update(message)\n            return\n        if location:\n            alt_access = access[su &amp; (access[\"location\"] != path)]\n            if len(alt_access):\n                # making sure not to revoke access from target parents if access is granted from another location\n                protected_paths: \"set[str]\" = set(alt_access[\"location\"])\n                alt_parents = (\n                    ([alt_path], n_back) for alt_path, n_back in zip(alt_access[\"location\"], alt_access[\"parents\"])\n                )\n                for alt_base, max_parent in alt_parents:\n                    for _ in range(max_parent):\n                        alt_base[0] = dirname(alt_base[0])\n                        if alt_base[0]:\n                            protected_paths.add(alt_base[0])\n                parents = access.loc[su &amp; (access[\"location\"] == path), \"parents\"]\n                if len(parents) == 1:\n                    _apply_to_parent(user, path, parents.iloc[0])\n            res = _revoke(user, path)\n            removed = removed &amp; (access[\"location\"] == path)\n            if res.stderr == b\"\":\n                _log(f\"removed permissions from {user}: they can no longer access {path}\")\n            else:\n                any_fail = True\n        else:\n            user_access = access[su]\n            any_parent_fail = False\n            for path, parents in zip(user_access[\"location\"], user_access[\"parents\"]):\n                parent = path\n                for _ in range(parents):\n                    parent = dirname(parent)\n                    if parent:\n                        res = _revoke(user, parent, False)\n                        if res.stderr != b\"\":\n                            any_parent_fail = True\n                    else:\n                        break\n                res = _revoke(user, path)\n                if res.stderr != b\"\":\n                    any_parent_fail = True\n            if not any_parent_fail:\n                _log(f\"removed all permissions from {user}\")\n            else:\n                access.loc[su, \"permissions\"] = \"---\"\n                any_fail = True\n        group_access = access[~su &amp; (access[\"group\"] == user)]\n        if len(group_access):\n            removed = removed | (access[\"group\"] == user)\n            if location:\n                group_access = group_access[group_access[\"location\"] == path]\n                if len(group_access):\n                    for sub_user in group_access[\"user\"]:\n                        res = _revoke(sub_user, path)\n                        if res.stderr == b\"\":\n                            _log(f\"removed permissions from {sub_user}: they can no longer access {path} under {user}\")\n                        else:\n                            any_fail = True\n                    removed = removed &amp; (access[\"location\"] == path)\n            else:\n                for sub_user, path in zip(group_access[\"user\"], group_access[\"location\"]):\n                    res = _revoke(sub_user, path)\n                    if res.stderr == b\"\":\n                        _log(f\"removed permissions from {sub_user}: they can no longer access {path} under {user}\")\n                    else:\n                        any_fail = True\n        if any_fail:\n            access.loc[removed, \"permissions\"] = \"---\"\n            _git_update(\n                \"failed to remove \"\n                + (f\"access to {location} ({path}) from {user}\" if location else f\"all access from {user}\")\n                + \", so setting blank permissions temporarily\"\n            )\n        else:\n            access[~removed].to_csv(ACCESS_FILE, index=False)\n            _git_update(\n                f\"removed access to {location} ({path}) from {user}\" if location else f\"removed all access from {user}\"\n            )\n    elif not from_pending:\n        pending = _get_pendings()\n        su = pending[\"user\"] == user\n        if any(su):\n            pending[~su].to_csv(\"pending_\" + ACCESS_FILE, index=False)\n            message = f\"removed {user} from pending without setting permissions\"\n            _log(message)\n            _git_update(message)\n</code></pre>"},{"location":"functions/Access/#file_access_manager.access.set_permission","title":"<code>set_permission(location, user, group=None, permissions='rx', parents=1)</code>","text":"<p>Grant a user permission, and add them to a group.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>Name of a location, or path, to grant <code>user</code> <code>permissions</code> to.</p> required <code>user</code> <code>str</code> <p>Name of the user.</p> required <code>group</code> <code>str</code> <p>Group to assign the user to. Defaults to the user themselves. Here, groups grant the user the group's access, and any permissions assigned to the user in the group would be removed with the group not on removal from the group.</p> <code>None</code> <code>permissions</code> <code>str</code> <p>Permission string (e.g., \"rwx\").</p> <code>'rx'</code> <code>parents</code> <code>int</code> <p>Number of parent directories on which to set read and execute permissions.</p> <code>1</code> Source code in <code>file_access_manager\\access.py</code> <pre><code>def set_permission(location: str, user: str, group: Union[str, None] = None, permissions=\"rx\", parents=1):\n    \"\"\"\n    Grant a user permission, and add them to a group.\n\n    Args:\n        location (str): Name of a location, or path, to grant `user` `permissions` to.\n        user (str): Name of the user.\n        group (str): Group to assign the user to. Defaults to the user themselves. Here,\n            groups grant the user the group's access, and any permissions assigned to the\n            user in the group would be removed with the group not on removal from the group.\n        permissions (str): Permission string (e.g., \"rwx\").\n        parents (int): Number of parent directories on which to set read and execute permissions.\n    \"\"\"\n    access = _get_accesses()\n    defer = _get_config().get(\"defer\", False)\n    if isdir(location):\n        path = location\n    else:\n        path = _get_locations().get(location, \"\")\n        if not defer and not isdir(path):\n            msg = f\"location ({location}) does not exist\"\n            raise RuntimeError(msg)\n    path = path.replace(\"[\\\\/]$\", \"\")\n    if not group:\n        group = user\n    message = \"\"\n    if defer or (ID_PATH and subprocess.run([ID_PATH, user], check=False, capture_output=True).stderr != b\"\"):\n        pending = _get_pendings()\n        updated = _append_row(pending, user, group, path, permissions, parents)\n        if not updated.equals(pending):\n            updated.to_csv(\"pending_\" + ACCESS_FILE, index=False)\n            message = f\"added {user} to pending access for {location} in group {group}\"\n            _log(message)\n    else:\n        _apply_to_parent(user, path, parents)\n        res = _set_permissions(user, path, permissions)\n        if res.stderr == b\"\":\n            updated = _append_row(access, user, group, path, permissions, parents)\n            if not updated.equals(access):\n                updated.to_csv(ACCESS_FILE, index=False)\n                message = f\"set permissions to {location} for {user} in group {group}\"\n                _log(message)\n        else:\n            print(res.stderr)\n            _log(f\"failed to set permissions for {user}\")\n    if message:\n        _git_update(message)\n</code></pre>"},{"location":"functions/Access/#command-line","title":"Command Line","text":"<pre><code>usage: manage-access [-h] [-p PERMISSIONS] [-r REMOVE] [-n PARENTS]\n                     [location] [user] [group]\n\nManage access.\n\npositional arguments:\n  location              path, or name of a location\n  user                  name of the user to grant access to\n  group                 group to assign the user to\n\noptions:\n  -h, --help            show this help message and exit\n  -p PERMISSIONS, --perms PERMISSIONS\n                        permissions to set to the user\n  -r REMOVE, --remove REMOVE\n                        user to revoke access from\n  -n PARENTS, --parents PARENTS\n                        number of parent directories to also assign read and\n                        execute permission to\n</code></pre>"},{"location":"functions/Access/#pending","title":"pending","text":"<pre><code>usage: manage-access pending [-h] [-i] [-o] [-u]\n\nCheck pending users, and apply permissions if they now exist.\n\noptions:\n  -h, --help       show this help message and exit\n  -i, --no-pull    do not git pull before checking pending\n  -o, --push       git commit and push after applying pending\n  -u, --no-update  do not update pending and access files\n</code></pre>"},{"location":"functions/Access/#check","title":"check","text":"<pre><code>usage: manage-access check [-h] [-l LOCATION] [-g GROUP] [-p] [-a] [user]\n\nCheck pending users, and apply permissions if they now exist.\n\npositional arguments:\n  user                  name of a user to check access for\n\noptions:\n  -h, --help            show this help message and exit\n  -l LOCATION, --location LOCATION\n                        name or path of a location to check access to\n  -g GROUP, --group GROUP\n                        name of a group to check access for\n  -p, --no-pull         disable pull from remote before checking access\n  -a, --no-reapply      disable application during check\n</code></pre>"},{"location":"functions/Locations/","title":"Locations","text":"<p>Manage named locations.</p>"},{"location":"functions/Locations/#file_access_manager.locations.add_location","title":"<code>add_location(name, path)</code>","text":"<p>Add a named location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to the location.</p> required <code>path</code> <code>str</code> <p>Path of the location.</p> required Source code in <code>file_access_manager\\locations.py</code> <pre><code>def add_location(name: str, path: str):\n    \"\"\"\n    Add a named location.\n\n    Args:\n        name (str): Name to assign to the location.\n        path (str): Path of the location.\n    \"\"\"\n    locations = _get_locations()\n    if name in locations and path == locations[name]:\n        return\n    if not isdir(path):\n        warnings.warn(f\"{path} does not exist\", stacklevel=2)\n    action = \"edited\" if name in locations else \"created\"\n    message = f\"{action} named location: {name} = {path}\"\n    locations[name] = path\n    with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n        json.dump(locations, opened, indent=2, sort_keys=True)\n    print(message)\n    _git_update(message)\n</code></pre>"},{"location":"functions/Locations/#file_access_manager.locations.list_locations","title":"<code>list_locations()</code>","text":"<p>View named locations.</p> Source code in <code>file_access_manager\\locations.py</code> <pre><code>def list_locations():\n    \"\"\"\n    View named locations.\n    \"\"\"\n    locations = _get_locations()\n    if len(locations):\n        message = \"Named locations:\"\n        for name, path in locations.items():\n            message += f\"\\n  - {name}: {path}\"\n    else:\n        message = \"No named locations on record.\"\n    print(message)\n    return message\n</code></pre>"},{"location":"functions/Locations/#file_access_manager.locations.remove_location","title":"<code>remove_location(name)</code>","text":"<p>Remove a named location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the location to remove.</p> required Source code in <code>file_access_manager\\locations.py</code> <pre><code>def remove_location(name: str):\n    \"\"\"\n    Remove a named location.\n\n    Args:\n        name (str): Name of the location to remove.\n    \"\"\"\n    locations = _get_locations()\n    if name in locations:\n        print(f\"removed named location `{name}`\")\n        locations.pop(name)\n        with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n            json.dump(locations, opened, indent=2, sort_keys=True)\n    else:\n        print(f\"`{name}` is not a named location\")\n</code></pre>"},{"location":"functions/Locations/#command-line","title":"Command Line","text":"<pre><code>usage: manage-access locations [-h] [-r REMOVE] [name] [path]\n\nManage named locations.\n\npositional arguments:\n  name                  name of the location\n  path                  path to be named\n\noptions:\n  -h, --help            show this help message and exit\n  -r REMOVE, --remove REMOVE\n                        name to be removed\n</code></pre>"},{"location":"functions/Projects/","title":"Projects","text":"<p>Project initialization and management.</p>"},{"location":"functions/Projects/#file_access_manager.project.init_manager_project","title":"<code>init_manager_project(base_dir='.', managers=None, locations=None, git_remote=None, auto_commit=True, auto_push=False, defer=False, git_branch='main')</code>","text":"<p>Initialize a file access management project.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>str</code> <p>Path to a directory in which to establish the project.</p> <code>'.'</code> <code>managers</code> <code>list[str]</code> <p>A list of users who should have full access to all locations.</p> <code>None</code> <code>locations</code> <code>dict[str, str]</code> <p>A dictionary of initial locations, with names associated with paths.</p> <code>None</code> <code>git_remote</code> <code>str</code> <p>Location of a remote repository.</p> <code>None</code> <code>auto_commit</code> <code>bool</code> <p>If <code>False</code>, will not commit after each action. This is added to the <code>config.json</code> file.</p> <code>True</code> <code>auto_push</code> <code>bool</code> <p>If <code>True</code>, will push to the remote after each action. This is added to the <code>config.json</code> file.</p> <code>False</code> <code>defer</code> <code>bool</code> <p>If <code>True</code>, will always add users to pending, leaving actual access granting to a later process.</p> <code>False</code> <code>git_branch</code> <code>str</code> <p>Name of the branch to initially pull in or create.</p> <code>'main'</code> Source code in <code>file_access_manager\\project.py</code> <pre><code>def init_manager_project(\n    base_dir=\".\",\n    managers: \"Union[list[str], None]\" = None,\n    locations: \"Union[dict[str, str], None]\" = None,\n    git_remote: \"Union[str, None]\" = None,\n    auto_commit=True,\n    auto_push=False,\n    defer=False,\n    git_branch=\"main\",\n):\n    \"\"\"\n    Initialize a file access management project.\n\n    Args:\n        base_dir (str): Path to a directory in which to establish the project.\n        managers (list[str]): A list of users who should have full access to all locations.\n        locations (dict[str, str]): A dictionary of initial locations, with names associated with paths.\n        git_remote (str): Location of a remote repository.\n        auto_commit (bool): If `False`, will not commit after each action. This is added to the `config.json` file.\n        auto_push (bool): If `True`, will push to the remote after each action. This is added to the `config.json` file.\n        defer (bool): If `True`, will always add users to pending, leaving actual access granting to a later process.\n        git_branch (str): Name of the branch to initially pull in or create.\n    \"\"\"\n    makedirs(base_dir, exist_ok=True)\n    chdir(base_dir)\n    fresh = False\n    if GIT_PATH:\n        subprocess.run([GIT_PATH, \"init\"], check=False, capture_output=True)\n    if git_remote:\n        if not GIT_PATH:\n            msg = \"`git` is not available\"\n            raise RuntimeError(msg)\n        subprocess.run([GIT_PATH, \"remote\", \"add\", \"origin\", git_remote], check=False)\n    if (\n        GIT_PATH\n        and not isfile(\".gitignore\")\n        and subprocess.run([GIT_PATH, \"pull\", \"origin\", git_branch], check=False, capture_output=True).stderr != b\"\"\n    ):\n        # first-time git setup\n        fresh = True\n        subprocess.run([GIT_PATH, \"checkout\", \"-b\", git_branch], check=False, capture_output=True)\n        with open(\".gitignore\", \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\".*\\n!.gitignore\")\n    set_options(auto_commit=auto_commit, auto_push=auto_push, defer=defer)\n    if managers:\n        managers_file = \"managers.txt\"\n        if isfile(managers_file):\n            with open(managers_file, encoding=\"utf-8\") as opened:\n                for user in opened.readlines():\n                    if user not in managers:\n                        managers.append(user)\n        with open(managers_file, \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\"\\n\".join(managers))\n    if locations:\n        if isfile(LOCATIONS_FILE):\n            with open(LOCATIONS_FILE, encoding=\"utf-8\") as opened:\n                locations = {**json.load(opened), **locations}\n        with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n            json.dump(locations, opened, indent=2, sort_keys=True)\n    elif not isfile(LOCATIONS_FILE):\n        with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\"{}\")\n    Path.touch(Path(\"log.txt\"), exist_ok=True)\n    if not isfile(ACCESS_FILE):\n        pandas.DataFrame(columns=list(ACCESS_STRUCTURE.keys())).to_csv(ACCESS_FILE, index=False)\n    if not isfile(\"pending_\" + ACCESS_FILE):\n        pandas.DataFrame(columns=list(ACCESS_STRUCTURE.keys())).to_csv(\"pending_\" + ACCESS_FILE, index=False)\n    if not isfile(\"README.md\"):\n        with open(\"README.md\", \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\n                \"\\n\\n\".join(\n                    [\n                        \"This is an access management project initialized by `manage-access init` from the\"\n                        \" [file_access_manager](https://dissc-yale.github.io/file_access_manager/) package.\",\n                        \"Install that package with pip:\",\n                        \"```sh\\npip install git+https://github.com/DISSC-yale/file_access_manager.git\\n```\",\n                        \"Then you can use the `manage-access` commands:\",\n                        \"```sh\\nmanage-access -h\\nmanage-access locations -h\\n```\",\n                    ]\n                )\n            )\n    _git_update(\"initial commit\" if fresh else \"reinitialized\")\n</code></pre>"},{"location":"functions/Projects/#file_access_manager.project.set_options","title":"<code>set_options(**kwargs)</code>","text":"<p>Set Project Options</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Union[bool, str]</code> <p>Named options with associated values:</p> <ul> <li><code>auto_commit</code>: If <code>False</code>, will not git commit each access actions; defaults to <code>True</code>.</li> <li><code>auto_push</code>: If <code>True</code>, will not git push each access actions; defaults to <code>False</code>.</li> <li><code>defer</code>: If <code>True</code>, will always initially add users to pending without checking if they     exist, leaving permission setting to a separate process; defaults to <code>False</code>.</li> </ul> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; file_access_manager.set_options(defer=True)\n</code></pre> Source code in <code>file_access_manager\\project.py</code> <pre><code>def set_options(**kwargs: Union[bool, str]):\n    \"\"\"\n    Set Project Options\n\n    Args:\n        **kwargs: Named options with associated values:\n\n            - `auto_commit`: If `False`, will not git commit each access actions; defaults to `True`.\n            - `auto_push`: If `True`, will not git push each access actions; defaults to `False`.\n            - `defer`: If `True`, will always initially add users to pending without checking if they\n                exist, leaving permission setting to a separate process; defaults to `False`.\n\n    Examples:\n        &gt;&gt;&gt; file_access_manager.set_options(defer=True)\n    \"\"\"\n    file = \"config.json\"\n    current = _get_config()\n    for name, value in kwargs.items():\n        if name not in [\"auto_commit\", \"auto_push\", \"defer\"]:\n            msg = f\"{name} is not a recognized option\"\n            raise RuntimeError(msg)\n        if value is not None:\n            current[name] = value if isinstance(value, bool) else value.lower() == \"true\"\n    with open(file, \"w\", encoding=\"utf-8\") as opened:\n        json.dump(current, opened, indent=2, sort_keys=True)\n    return current\n</code></pre>"},{"location":"functions/Projects/#command-line","title":"Command Line","text":""},{"location":"functions/Projects/#init","title":"init","text":"<pre><code>usage: manage-access init [-h] [-m [MANAGERS ...]] [-r REMOTE] [-b BRANCH]\n                          [base_dir]\n\nInitialize an access manager project.\n\npositional arguments:\n  base_dir              directory of the access manager project\n\noptions:\n  -h, --help            show this help message and exit\n  -m [MANAGERS ...], --managers [MANAGERS ...]\n                        manager users\n  -r REMOTE, --remote REMOTE\n                        git remote\n  -b BRANCH, --branch BRANCH\n                        git branch\n</code></pre>"},{"location":"functions/Projects/#config","title":"config","text":"<pre><code>usage: manage-access config [-h] [-c AUTO_COMMIT] [-p AUTO_PUSH] [-d DEFER]\n\nConfigure an access manager project.\n\noptions:\n  -h, --help            show this help message and exit\n  -c AUTO_COMMIT, --auto_commit AUTO_COMMIT\n                        automatically commit access actions\n  -p AUTO_PUSH, --auto_push AUTO_PUSH\n                        automatically push committed access actions\n  -d DEFER, --defer DEFER\n                        defer access setting to a separate process\n</code></pre>"}]}