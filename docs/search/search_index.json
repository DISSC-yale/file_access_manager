{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Python command-line interface package to manage access to directories.</p> <p>The main use-case in mind is to manage access of researchers to data files.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Grant or revoke access of users or groups of users (e.g., principal investigators and their collaborators or research assistants)</li> <li>Keep a list of users needing access, pending account creation</li> <li>Establish named paths (e.g., dataset names associated with their location)</li> <li>Track access status changes of users and datasets</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<p>This package manages access through Access Control Lists, so this should work on any system with the <code>getfacl</code> and <code>setfacl</code> commands.</p>"},{"location":"#installation","title":"Installation","text":"<p>If needed, download Python from python.org, then install the package with pip:</p> <pre><code>pip install git+https://github.com/DISSC-yale/file_access_manager.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Initialize an access management project:</p> <pre><code>manage-access init\n</code></pre> <p>Name a location:</p> <pre><code>manage-access locations location_name /full/path/to/location\n</code></pre> <p>Manage access to that location:</p> <pre><code># add a user\nmanage-access location_name user1\n\n# add a user to that user's group\nmanage-access location_name user2 user1\n\n# remove user and their group(s) from all locations\nmanage-access -r user1\n</code></pre>"},{"location":"Projects/","title":"Projects","text":"<p>Projects keep a record of access and changes to access. Initialize a project with the init command:</p> <pre><code>manage-access init ./access_record\ncd access_record\n</code></pre> <p>This will create the following initial files:</p> <pre><code>access_record/\n  .git\n  .gitignore\n  access.csv\n  config.json\n  locations.json\n  log.txt\n  pending_access.csv\n</code></pre> <p><code>access.csv</code> keeps a record of what should be current user access. It is a comma delimited file with these columns:</p> <ul> <li><code>user</code>: Name of the user receiving access.</li> <li><code>group</code>: Group under which the user is receiving access. This will default to the user themselves.</li> <li><code>location</code>: Path to the directory the user is receiving access to.</li> <li><code>permissions</code>: Type of access the user should have; <code>rx</code> by default.</li> <li><code>date</code>: Date and time at which permission was set.</li> </ul> <p>This is added to each time a user is granted access to a location, and is removed from when that access is revoked.</p> <p><code>pending_access.csv</code> is the same structure as <code>access.csv</code>. Users are added here if they cannot be found on the system.</p> <p><code>locations.json</code> keeps an association between names and full paths, for convenience. This is only used for initial translation, such that stored references to locations are always the associated path, rather than the name.</p> <p><code>log.txt</code> keeps a log of events.</p>"},{"location":"functions/Access/","title":"Access","text":"<p>Manage user access.</p>"},{"location":"functions/Access/#file_access_manager.access.check_pending","title":"<code>check_pending()</code>","text":"<p>Check any users pending access, and apply permissions if they now exist.</p> Source code in <code>src\\file_access_manager\\access.py</code> <pre><code>def check_pending():\n    \"\"\"Check any users pending access, and apply permissions if they now exist.\"\"\"\n    pending_file = \"pending_\" + ACCESS_FILE\n    if isfile(pending_file):\n        pending = _get_pendings()\n        updated = False\n        for user, access in pending.groupby(\"user\"):\n            if _user_exists(user):\n                for location, permissions in zip(access[\"location\"], access[\"permissions\"]):\n                    _set_permissions(user, location, permissions)\n                pending = pending[pending[\"user\"] != user]\n                _log(f\"removed {user} from pending after setting permissions\")\n                updated = True\n        if updated:\n            pending.to_csv(ACCESS_FILE, index=False)\n            _git_update(\"processed pending permissions\")\n    else:\n        print(\"no pending users\")\n</code></pre>"},{"location":"functions/Access/#file_access_manager.access.set_permission","title":"<code>set_permission(location, user, group=None, permissions='rx')</code>","text":"<p>Grant a user permission, and add them to a group.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>Name of a location, or path, to grant <code>user</code> <code>permissions</code> to.</p> required <code>user</code> <code>str</code> <p>Name of the user.</p> required <code>group</code> <code>str</code> <p>Group to assign the user to. Defaults to the user themselves. Here, groups grant the user the group's access, and any permissions assigned to the user in the group would be removed with the group not on removal from the group.</p> <code>None</code> <code>permissions</code> <code>str</code> <p>Permission string (e.g., \"rwx\").</p> <code>'rx'</code> Source code in <code>src\\file_access_manager\\access.py</code> <pre><code>def set_permission(location: str, user: str, group: \"Union[str, None]\" = None, permissions=\"rx\"):\n    \"\"\"\n    Grant a user permission, and add them to a group.\n\n    Args:\n        location (str): Name of a location, or path, to grant `user` `permissions` to.\n        user (str): Name of the user.\n        group (str): Group to assign the user to. Defaults to the user themselves. Here,\n            groups grant the user the group's access, and any permissions assigned to the\n            user in the group would be removed with the group not on removal from the group.\n        permissions (str): Permission string (e.g., \"rwx\").\n    \"\"\"\n    access = _get_accesses()\n    if isdir(location):\n        path = location\n    else:\n        path = _get_locations().get(location, \"\")\n        if not isdir(path):\n            msg = f\"location ({location}) does not exist\"\n            raise RuntimeError(msg)\n    if not group:\n        group = user\n    message = \"\"\n    if ID_PATH and subprocess.run([ID_PATH, user], check=False, capture_output=True).stderr != b\"\":\n        pending = _get_pendings()\n        updated = _append_row(pending, user, group, path, permissions)\n        if len(pending) != len(updated):\n            updated.to_csv(\"pending_\" + ACCESS_FILE, index=False)\n            message = f\"added {user} to pending access for {location} in group {group}\"\n            _log(message)\n    else:\n        res = _set_permissions(user, path, permissions)\n        if res.stderr == b\"\":\n            updated = _append_row(access, user, group, path, permissions)\n            if len(access) != len(updated):\n                updated.to_csv(ACCESS_FILE, index=False)\n                message = f\"set permissions to {location} for {user} in group {group}\"\n                _log(message)\n        else:\n            print(res.stderr)\n            _log(f\"failed to set permissions for {user}\")\n    if message:\n        _git_update(message)\n</code></pre>"},{"location":"functions/Locations/","title":"Locations","text":"<p>Manage named locations.</p>"},{"location":"functions/Locations/#file_access_manager.locations.add_location","title":"<code>add_location(name, path)</code>","text":"<p>Add a named location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to the location.</p> required <code>path</code> <code>str</code> <p>Path of the location.</p> required Source code in <code>src\\file_access_manager\\locations.py</code> <pre><code>def add_location(name: str, path: str):\n    \"\"\"\n    Add a named location.\n\n    Args:\n        name (str): Name to assign to the location.\n        path (str): Path of the location.\n    \"\"\"\n    locations = _get_locations()\n    if name in locations and path == locations[name]:\n        return\n    if not isdir(path):\n        warnings.warn(f\"{path} does not exist\", stacklevel=2)\n    action = \"edited\" if name in locations else \"created\"\n    message = f\"{action} named location: {name} = {path}\"\n    locations[name] = path\n    with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n        json.dump(locations, opened, indent=2, sort_keys=True)\n    print(message)\n    _git_update(message)\n</code></pre>"},{"location":"functions/Locations/#file_access_manager.locations.list_locations","title":"<code>list_locations()</code>","text":"<p>View named locations.</p> Source code in <code>src\\file_access_manager\\locations.py</code> <pre><code>def list_locations():\n    \"\"\"\n    View named locations.\n    \"\"\"\n    locations = _get_locations()\n    if len(locations):\n        message = \"Named locations:\"\n        for name, path in locations.items():\n            message += f\"\\n  - {name}: {path}\"\n    else:\n        message = \"No named locations on record.\"\n    print(message)\n    return message\n</code></pre>"},{"location":"functions/Locations/#file_access_manager.locations.remove_location","title":"<code>remove_location(name)</code>","text":"<p>Remove a named location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the location to remove.</p> required Source code in <code>src\\file_access_manager\\locations.py</code> <pre><code>def remove_location(name: str):\n    \"\"\"\n    Remove a named location.\n\n    Args:\n        name (str): Name of the location to remove.\n    \"\"\"\n    locations = _get_locations()\n    if name in locations:\n        print(f\"removed named location `{name}`\")\n        locations.pop(name)\n        with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n            json.dump(locations, opened, indent=2, sort_keys=True)\n    else:\n        print(f\"`{name}` is not a named location\")\n</code></pre>"},{"location":"functions/Projects/","title":"Projects","text":"<p>Project initialization and management.</p>"},{"location":"functions/Projects/#file_access_manager.project.init_manager_project","title":"<code>init_manager_project(base_dir='.', managers=None, locations=None, git_remote=None, auto_commit=True, auto_push=False, git_branch='main')</code>","text":"<p>Initialize a file access management project.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>str</code> <p>Path to a directory in which to establish the project.</p> <code>'.'</code> <code>managers</code> <code>list[str]</code> <p>A list of users who should have full access to all locations.</p> <code>None</code> <code>locations</code> <code>dict[str, str]</code> <p>A dictionary of initial locations, with names associated with paths.</p> <code>None</code> <code>git_remote</code> <code>str</code> <p>Location of a remote repository.</p> <code>None</code> <code>auto_commit</code> <code>bool</code> <p>If <code>False</code>, will not commit after each action. This is added to the <code>config.json</code> file.</p> <code>True</code> <code>auto_push</code> <code>bool</code> <p>If <code>True</code>, will push to the remote after each action. This is added to the <code>config.json</code> file.</p> <code>False</code> <code>git_branch</code> <code>str</code> <p>Name of the branch to initially pull in or create.</p> <code>'main'</code> Source code in <code>src\\file_access_manager\\project.py</code> <pre><code>def init_manager_project(\n    base_dir=\".\",\n    managers: \"Union[list[str], None]\" = None,\n    locations: \"Union[dict[str, str], None]\" = None,\n    git_remote: \"Union[str, None]\" = None,\n    auto_commit=True,\n    auto_push=False,\n    git_branch=\"main\",\n):\n    \"\"\"\n    Initialize a file access management project.\n\n    Args:\n        base_dir (str): Path to a directory in which to establish the project.\n        managers (list[str]): A list of users who should have full access to all locations.\n        locations (dict[str, str]): A dictionary of initial locations, with names associated with paths.\n        git_remote (str): Location of a remote repository.\n        auto_commit (bool): If `False`, will not commit after each action. This is added to the `config.json` file.\n        auto_push (bool): If `True`, will push to the remote after each action. This is added to the `config.json` file.\n        git_branch (str): Name of the branch to initially pull in or create.\n    \"\"\"\n    makedirs(base_dir, exist_ok=True)\n    chdir(base_dir)\n    fresh = False\n    if GIT_PATH:\n        subprocess.run([GIT_PATH, \"init\"], check=False, capture_output=True)\n    if git_remote:\n        if not GIT_PATH:\n            msg = \"`git` is not available\"\n            raise RuntimeError(msg)\n        subprocess.run([GIT_PATH, \"remote\", \"add\", \"origin\", git_remote], check=False)\n    if (\n        GIT_PATH\n        and not isfile(\".gitignore\")\n        and subprocess.run([GIT_PATH, \"pull\", \"origin\", git_branch], check=False, capture_output=True).stderr != b\"\"\n    ):\n        # first-time git setup\n        fresh = True\n        subprocess.run([GIT_PATH, \"checkout\", \"-b\", git_branch], check=False, capture_output=True)\n        with open(\".gitignore\", \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\".*\\n!.gitignore\")\n    config = _get_config()\n    config[\"auto_commit\"] = auto_commit\n    config[\"auto_push\"] = auto_push\n    with open(\"config.json\", \"w\", encoding=\"utf-8\") as opened:\n        json.dump(config, opened, indent=2, sort_keys=True)\n    if managers:\n        managers_file = \"managers.txt\"\n        if isfile(managers_file):\n            with open(managers_file, encoding=\"utf-8\") as opened:\n                for user in opened.readlines():\n                    if user not in managers:\n                        managers.append(user)\n        with open(managers_file, \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\"\\n\".join(managers))\n    if locations:\n        if isfile(LOCATIONS_FILE):\n            with open(LOCATIONS_FILE, encoding=\"utf-8\") as opened:\n                locations = {**json.load(opened), **locations}\n        with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n            json.dump(locations, opened, indent=2, sort_keys=True)\n    elif not isfile(LOCATIONS_FILE):\n        with open(LOCATIONS_FILE, \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\"{}\")\n    Path.touch(Path(\"log.txt\"), exist_ok=True)\n    if not isfile(ACCESS_FILE):\n        pandas.DataFrame(columns=list(ACCESS_STRUCTURE.keys())).to_csv(ACCESS_FILE, index=False)\n        pandas.DataFrame(columns=list(ACCESS_STRUCTURE.keys())).to_csv(\"pending_\" + ACCESS_FILE, index=False)\n    if not isfile(\"README.md\"):\n        with open(\"README.md\", \"w\", encoding=\"utf-8\") as opened:\n            opened.write(\n                \"\\n\\n\".join(\n                    [\n                        \"This is an access management project initialized by `manage-access init` from the\"\n                        \" [file_access_manager](https://dissc-yale.github.io/file_access_manager/) package.\",\n                        \"Install that package with pip:\",\n                        \"```sh\\npip install git+https://github.com/DISSC-yale/file_access_manager.git\\n```\",\n                        \"Then you can use the `manage-access` commands:\",\n                        \"```sh\\nmanage-access -h\\nmanage-access locations -h\\n```\",\n                    ]\n                )\n            )\n    _git_update(\"initial commit\" if fresh else \"reinitialized\")\n</code></pre>"}]}